"""
Project builder module.

Takes generated files, writes them into a temporary directory tree,
and produces a zip archive that Streamlit can offer for download.
"""

from __future__ import annotations

import io
import os
import tempfile
import zipfile
from pathlib import Path


def build_project_zip(
    files: dict[str, str],
    project_name: str = "research_implementation",
) -> io.BytesIO:
    """
    Create an in-memory zip archive from generated source files.

    Parameters
    ----------
    files : dict[str, str]
        Mapping of relative filename → source code content.
    project_name : str
        Name of the root folder inside the zip.

    Returns
    -------
    buf : io.BytesIO
        A seeked-to-zero bytes buffer containing the zip.
    """
    buf = io.BytesIO()
    with zipfile.ZipFile(buf, "w", zipfile.ZIP_DEFLATED) as zf:
        for fname, content in files.items():
            arcname = f"{project_name}/{fname}"
            zf.writestr(arcname, content)

        # Add a README
        readme = _generate_readme(files, project_name)
        zf.writestr(f"{project_name}/README.md", readme)

    buf.seek(0)
    return buf


def build_project_directory(
    files: dict[str, str],
    project_name: str = "research_implementation",
) -> Path:
    """
    Write generated files to a real temporary directory.

    Returns the root ``Path`` of the created project.
    """
    base = Path(tempfile.mkdtemp()) / project_name
    base.mkdir(parents=True, exist_ok=True)

    for fname, content in files.items():
        fpath = base / fname
        fpath.parent.mkdir(parents=True, exist_ok=True)
        fpath.write_text(content, encoding="utf-8")

    # README
    readme = _generate_readme(files, project_name)
    (base / "README.md").write_text(readme, encoding="utf-8")

    return base


def file_tree_string(files: dict[str, str], project_name: str = "research_implementation") -> str:
    """Return a pretty-printed directory tree string."""
    lines = [f"{project_name}/"]
    sorted_files = sorted(files.keys())
    for i, fname in enumerate(sorted_files):
        connector = "└── " if i == len(sorted_files) - 1 else "├── "
        lines.append(f"  {connector}{fname}")
    lines.append(f"  └── README.md")
    return "\n".join(lines)


def _generate_readme(files: dict[str, str], project_name: str) -> str:
    """Auto-generate a README for the project."""
    file_list = "\n".join(f"- `{f}`" for f in sorted(files.keys()))
    return f"""# {project_name.replace('_', ' ').title()}

> Auto-generated by **Research Paper Explainer & Implementation Generator**

## Files

{file_list}

## Quick Start

```bash
pip install -r requirements.txt
python train.py
```

## Notes

- Review and adjust `config.yaml` for your hardware.
- Generated code is a starting point — verify against the original paper.
"""
